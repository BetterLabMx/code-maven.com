=title Fight or Flight? - dealing with real world applications in Python
=timestamp 2016-04-01T07:30:01
=indexes pytest, mock
=status draft
=books python
=author szabgab
=archive 1
=comments_disqus_enable 1

=abstract start

You have just landed a new job as a hero Python developer. Your first task is simple. Make a little tweak to an existing application.
To your horror you discover the code is a mess written in the past 10 years by many different people who have just started their career as Python programmers.
They all have already move on. They left behind the code, but it has no tests and no documentation. Oh and by the way, the company depends on the application.
What do you do now? Fight or flight? In this talk you will hear about a couple of ways to fight with such a beast.

=abstract end

<h2>The ideal situation</h2>

When you join a company, or switch teams you have certain expectation about the development envrinment and process.
The ideal situation looks something like this.

The team use some distributed <b>version control system</b>.  <a href="https://git-scm.com/">Git</a> is your preference,
but you'd be ok with something similar as well.

The code is divided into small functions or methods with clear input and output for each function with very little, or possibly no side-effects.
If there are side effects they are well documented.

The modules and objects are loosely coupled. While this might be harder to measure than length or complexity of functions,
but circural dependencies (e.g  module A loads module B which loads module C which load module A) is likely an indication of something
problematic. If you cannot give good names to thing (e.g. you have too many variables called <b>data</b> or <b>input</b> or <b>text</b>)
that's usually also a good indication.

Microservices. Well, that's just a modren buzz-word, but the point is that if the application is separated in
clear units with clear borders, that's ususally much better than a large monolithic application.

Documentation of the decisions made and the external API of each module. Many people don't like to write documentation
because of various reasons. For example they saw too much boiler-plate documentation where a large chunk of it is redundant
or irrelevant. (Who wrote the code, what changes were made, when. This can be extracted from the version control system.)
The main purpose of the function should be clear from its name.
Others just fear their writing capabilities in English is not good enough.

You expect to have plenty of unit and integration tests together with the code covering most if not all the codebase.

You expect to have Continuous Integration (CI) system running on the code base reporting if anything gets broken.

You also expect to have a separate development envrionment for each developer, including your own copy of
the data. A separate testing or staging environment that is identical to the production environment even it is much smaller.

<h2>The real situation</h2>

The real situation is however very differernt. There are cases where the soure code lives on the production server.
There might be a script to save backup copies with time stamp (the first seeds of a home-made version control system)
but that's it. You don't have a development environment not to even mention a testing environment.

In other cases you might have a separate development environment, even a version control system,
but there is only a single central database of the production data. You have to work on that.

The functions are huge, several hundred sometimes even a thousand lines each.
In addition they call each other in a rather unpredictable manner in many cases
creating circular dependencies of tightly coupled modules.

Here are two modules that each depends on the other:

<include file="examples/python/fof/my_a.py">

<include file="examples/python/fof/my_b.py">


The code is full of global variables and code that touch attributes in other modules.

For example this module looks ok (except the naming):

<include file="examples/python/fof/xb.py">

But then if we use it this way: 

<include file="examples/python/fof/xa.py">

then it will be very difficult to understand the code. Especially in large, applications
where any piece of code might access <hl>xb.var</hl>.

People might have even employed monkey patching to make some code
work they want it to work.

In most of cases there are no tests and there is no documentation either, or if there is
it is either redundant out of date.

<h2>The Solution</h2>

There are basically two solutions for this. Fight or Flight.

<h2>Flight - find another workplace</h2>

If you feel the whole organization is soaked in a bad culture that won't allow for change then your best
bet might be to find another place to work. There are plenty of places that need good developers.

Just make sure you understand that ideal situation you hope for rarely exist. In every place
you'll see entropy in action.

If this is what you decide, you don't need to read on.

Or maybe you do, so you'll know what to do when things are not so perfect.

<h2>Fight</h2>

The real solution is to fight the situation. To start moving from the current situation towards the ideal one.
It will be a long process, but you'll learn a lot. It will have a lot of frustrating days, you'll encounter setbacks,
but step-by-step you'll be able to improve the situation.

Both for yourself and for the company in general which is crucial.
After all if you don't think the company will benefit from your work then you probably should not
do it while getting paid.

It is also importent because once you get management to understand the real value in the changes
you make it will be much easier for you to do them.

Therefore before we talk about the value this process will bring you, the develper, let's see
what does this bring to the business?

<h2>Business Value</h2>

I think we can describe this in two points:

<ul>
 <li>Increased speed of development (reduce the time to market)</li>
 <li>Increased quality of the products/services</li>
</ul>

Of course when you talk to people in management you might want to provide
a more detailed explanation. A few additional points that you might mention.

<ul>
   <li>Smaller number of bugs.</li>
   <li>Smaller number of system crashes for given period of time.</li>
   <li>Reduce the time spent in QA while increasing the quality.</li>
   <li>Shorter development cycles.</li>
   <li>Elimination of the "returning bugs".</li>
   <li>Reduce the possibility of changes breaking old code.</li>
</ul>

Is employee satisfaction a real thing? If your company cares, then you might mention the following
points as well. If not, then these are mostly for you and for your co-workers when you talk to them.

Try to get management buy-in, but if you cannot, and you still think the comany will benefit from it, do it anyway.
It is for your sanity.

<h2>Programmer value</h2>

<ul>
  <li>Protect your code.</li>
  <li>Reduce the fear, uncertainty, doubt to make changes.</li>
  <li>Reduce the difficulty to make changes.</li>
  <li>Reduce the WTF/minute in the code.</li>
  <li>Your sanity.</li>
</ul>

I am not really sure which one might be the most convincing among thes. Maybe the idea
that writing test for the feature you add will help you protect your code from future changes.
Both from your own future changes and from the changes other developers might inroduce
in libraries that your code uses.

I don't know about you, but when I touch an untested piece of code I get nerveous. I don't know how the changes I make 
might impact the rest of the application which slows me down a lot. I spend a lot of time worrying and a lot
of time trying to figure out if my changes don't break anything. I am never sure.

<h2>Measure your progress</h2>

Unlike developers, managers don't have a gut feeling about the code as they are too removed from it.
They need some way to measure your work. What is intersting for them, mentioned above, is the speed of development
and the quality of code.

Unfortunately in our industry we don't have really good way to estimate the length of a project. We are often off by
100-200% in our time estimate. This means that a 20% increase in development speed is still within the
"margin of error" for the estimation of the project. That's very hard to show. Especially as the projects we do
have a lot of differences and thus it is hard to compare them.

Number of bugs might be a better indication, but that too requires some way to compare projects. (Having
1 bug in an implementation of FizzBuzz is much worse than having 100 bugs in the implementation
of a flight management application, but having any of those 100 bugs can have a much worse impact.)

You probably wonâ€™t be able to properly measure any of these.
So we have to find other ways to measure our progress.

There are a number of other ways, that don't have a clear and direct impact on the business,
but they are measurable and provide some indication that we are in the right track.

<ul>
  <li>Code complexity.</li>
  <li>Test coverage  (which is probably 0 when you start).</li>
  <li>Standards or "best practices" compliance.</li>
  <li>Execution time, if relevant.</li>
  <li>Number of open tickets.</li>
</ul>

<h2>Version Control System: Git</h2>

If the company does not have it yet, then the very first thing you need to do is to set up some kind of a version control system.
It will help you make changes to the code and make it easy to go back to earlier version if you break something.
It will also help you notice if someone else has change the code.

Even if the company already has a version control system such as Clear Case, they might have made the development process cumbersome.
For example they might require a ticket in the bug tracking system to be opened and signed by a manager for each change.
This usually means people will tend to wait with their commit till "everything is finished" which eliminates one of the most
valuable aspects of a version control system. Having you own version control system will allow you to make lots of small commits and
then, when you are done you can commit to the official VCS of the company.

<a href="https://git-scm.com/">Git</a> is great for thsi as it does not need a server.

<h2>virtualenv</h2>

<a href="https://pypi.python.org/pypi/virtualenv">virtualenv</a> allows you to create an isolated environment for your Python code.
This will allow you to install packages you might need for testing without bothering others.

<h2>Write tests</h2>

Use one of the test frameworks of Python.

<a href="https://docs.python.org/2/library/doctest.html">doctest</a> and 
<a href="https://docs.python.org/2/library/unittest.html">unittest</a>
(and <a href="https://pypi.python.org/pypi/unittest2">unittest2</a>) come with the installation
of Python.

<a href="https://pypi.python.org/pypi/nose/">nose</a> and <a href="http://pytest.org/">pytest</a>
are more powerful.


It does not really matter which one you start using. As a new progammer on this team you'll have to learn a lot
about the code-base and the challenges it imposese for writing tests.

The more important question though is what kind of tests you should be writing?

People tend to use all kinds of magic words for various aspects of testing. I'd just point at two. OK maybe three.

<h2>Regression Test</h2>

There is no such thing as "writing regression test".
Every test becomes a regression test when you run it more than once.

That's where the real value of tests are.

<h2>Integration or unit tests ?</h2>

That's a much more reasonalbe question, but the distinction is far from clear.

In the ideal case, a unit test checks the behavior of a single function. It should not depend on
the behaviour of the functions called by the "function under test".

An "integration test" on the other hand would test how various subsystems work together.

In reality, however these can be seen as two extremes of a wide range of possible test.

They don't differ from each other much. They all have the simple equation of


<b>Input + Action == Expected result</b>


Or possible more correctly:


<b>Input + Action == Expected result + bugs</b>

In other words <b>"Integrations tests"</b> are the same as <b>"unit tests"</b>, just the units are bigger.

Morover in spaghetti code every unit test is also an integration tests as all the units are tightly "integrated".

In a nutshell, don't fret about the naming. Especially not at the beginning.
But be prepared to constantly refactor your tests as well.

I won't provide a deep tutorial to testing Python code, but let's just see a simple example.

<h2>First simple test</h2>

We have a module called <hl>my_calc.py</hl> that has a function called <hl>sum</hl>.
We can observe its behaviour with the following code:

<include file="examples/python/fof/use_calc.py">

Some people will actually write such examples while developing code to obseve the behaviour of their new code.
Then they will either discard it or let it lay around withut turning them into proper test scripts. It is quite unfortunate
becasue with little investment they could have converted it to long-lasting test.

In other words, they have paid the price of writing the tests without reaping the real benefits of it down the road
that they can execute the tests thousands of times.

<include file="examples/python/fof/test_my_calc.py">

We can easily run the test script and if everything works fine we get a report that looks lke this:

<code lang="bash">
$ py.test test_my_calc.py 
============================================ test session starts =============================================
platform linux2 -- Python 2.7.9, pytest-2.9.1, py-1.4.31, pluggy-0.3.1
rootdir: /vagrant/code-maven.com/examples/python/fof, inifile: 
collected 1 items 

test_my_calc.py .

========================================== 1 passed in 0.10 seconds ==========================================
</code>

If on the other hand something is broken we get results like this:

<code lang="bash">
$ py.test test_my_calc.py 
============================================ test session starts =============================================
platform linux2 -- Python 2.7.9, pytest-2.9.1, py-1.4.31, pluggy-0.3.1
rootdir: /vagrant/code-maven.com/examples/python/fof, inifile: 
collected 1 items 

test_my_calc.py F

================================================== FAILURES ==================================================
________________________________________________ test_mycalc _________________________________________________

    def test_mycalc():
        assert(my_calc.sum(2, 3) == 5)
>       assert(my_calc.sum(2, 3, 4) == 9)
E       assert 5 == 9
E        +  where 5 = <function sum at 0xb6cef79c>(2, 3, 4)
E        +    where <function sum at 0xb6cef79c> = my_calc.sum

test_my_calc.py:6: AssertionError
========================================== 1 failed in 0.30 seconds ==========================================
</code>

Just in case you'd like to try it, the actual code looks like this:

<include file="examples/python/fof/my_calc.py">


<h2>Continuous Integration</h2>

Once you have any tests it is time to set up some kind of Continuous Integration system. You can pick one of the
ready made CI systems such as <a href="https://en.wikipedia.org/wiki/Jenkins_%28software%29">Jenkins</a>,
<a href="https://en.wikipedia.org/wiki/Buildbot">Buildbot</a>, and I think even
<a href="https://en.wikipedia.org/wiki/Travis_CI">Travis-CI</a> can be installed, but I think I'd just start
with a simple cron-job and a few lines of Python code to fetch the latest revision of the code, run the tests
and send me an e-mail if something got broken.

This too will have to improve with time, but most likely the system you need to deal with is so specific to the company
that you'll have a lot of work setting up either of those systems.

<h2>Resources</h2>

Some of the resources I've used for this talk and article that I recommend you read:

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Best_coding_practices">Best Coding Practices</a></li>
  <li><a href="http://programmers.stackexchange.com/questions/157287/how-to-motivate-co-workers-to-write-unit-tests">How to motivate co-workers to write unit-tests?</a></li>
  <li><a href="http://stackoverflow.com/questions/416231/how-do-you-persuade-others-to-write-unit-tests">How do you persuade others to write unit tests?</a></li>
  <li><a href="http://pythontesting.net/">Python Testing blogs and podcast by Brian Okken</a></li>
  <li><a href="http://blog.stevensanderson.com/2009/08/24/writing-great-unit-tests-best-and-worst-practises/">Writing Great Unit Tests: Best and Worst Practices</a></li>
</ul>

